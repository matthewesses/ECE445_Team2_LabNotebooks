# Engineering Notebook ECE 445: Shreya Venkat

## 1/17: Found a Team
- Teamed up with Varik Gilmer and Matt Esses for the Seeing-Eye Hat Project.

## 1/18: Submitted my Initial Web Board Post
- I commented on one of the project ideas that was posted by another classmate. It was a keyboard with a trackpad, and I asked
  about the product's target audience and whether there would be an issue with unintended clicks from keys.
- Met with the team to go over the initial ideas for the project. The keystone for the project would be a LiDAR sensor.
- We learnt that there was a LiDAR stocked in the lab room, so we would not need to spend anything for it. These sensors are
  quite expensive.

## 1/19: Submitted our RFA for the Project
- A Doppler RADAR will also be necessary as a backup sensor when the LiDAR wouldn't function in a certain capacity.
- We are aiming to get extra credit from getting our project approved early.

## 1/22: Project Development
- To Do: Verify that the LiDAR is able to read distances.
- Varik's Arduino will be used to connect to it.

## 2/6: First meeting with TA Sanjana
- Decided to have meetings on Mondays, 10-10:30 am
- Assigned locker and locker combination.
- Sent over our proposal to be looked at.

## 2/11: Moved all TA meetings to 12-12:30 pm
- TA needed to reschedule meeting times, so we all settled on this time.

## 2/12: Regular TA Meeting #1
- We got our CFOP number, and started ordering our microcontrollers. We are primarily concerned with the STM32, but also want
  to order an ATMega.
- The ATMega will serve as a second microcontroller in conjunction with the STM32 if the STM doesn't have enough pins for the whole       project.

## 2/19: Regular TA Meeting #2
- We discussed the design document, which is due this Thursday. Also made aware that we needed to show circuit diagrams of
  our subsystems.
- We haven't made any diagrams, and will need to make them quickly by the design document deadline.

## 2/21: Update on Circuit Diagrams
- Sanjana emailed us: said that it is alright if we do not have the diagrams on the design document, as long as they are on
  the design review presentation.

## 2/26: TA Meeting Cancelled
- It is the week of design reviews, so we are not having a TA meeting today.
- We are presenting on Wednesday, 5 pm. Continuing work on the presentation.

## 2/28: Design Review
- We are hoping to not have to use the ATMega in our project, as we believe the STM32 should be enough, and will greatly simplify
  the control unit. Explained that it was the controller that had enough pins to meet our needs.
- We had all the circuit diagrams finished by this time. In terms of project division, I will be responsible for the control unit
  and the LiDAR on Imaging, Matt will take scanning and hall effect, and Varik will handle power. All other responsibilites can
  be handled by everyone as required.

## 3/4: Regular TA Meeting #3
- This was the last meeting before spring break. We are disappointed that we were not able to get in a first round PCB, but
  ultimately hope that the second round will be good enough for our needs.

## 3/18: Attempt to get a reading from the LiDAR
- The LiDAR is compatible with I2C, which we believe we can use to establish communication between it and the STM32.
- We will start off with the development STM32 board checked out to us.

## 3/19: Submitted our first round PCB!
- This is the second round audit for the class, but we were not able to get a PCB in during the first round.
- I am not very good with PCB design, so I opted to learn about Gerber file generation, and I will be submitting all PCB iterations
  going forward. Naturally, I will also be putting our designs through the audit.
- As for my assigned task, I don't know what I2C is, so I believe it will be in my best interest to do some research on it before I
  start trying to implement it with LiDAR and the STM32.

## 3/20: Began research on I2C Protocol
- I will use these notes as reference in case I need them later.
  
**Overview of I2C Protocol:** I2C has a single master, multiple slave setup.
- In the case of our project, the STM32 will act as the master and the LiDAR will be the slave device.
- There are two important lines I need to know about:
  1. SDA (Serial Data) is the line on which the master and the slave communicate information.
  2. SCL (Serial Clock) is the clock line for data flow synchronization.
     - It is generated by the master device and is responsible for synchronizing data transfer between the devices on the bus.
- Both of these lines are bi-directional.
- Devices on the I2C bus are active low, so they need pull up resistors to force the devices to high (inactive).

## 3/21: More I2C Research
**I2C Data Transfer Protocol:** The steps are listed below:
1. Start Condition: data line is low, clock line is high
2. First 8 bits come in: first 7 - address of the slave to which data is being sent, last 1 - read/write. 0 = master writes to slave, 1 = master reads from slave
3. Acknowledge Bit - used by slave device to indicate whether previous sequence of bits was successfully received. If yes, it pulls SDA line down.
4. 8 bit address representing the internal registers of the slave device
5. Acknowledge + Data Sequence. Transfer occurs from either master or slave depending on R/W mode.
6. Stop Condition: data line goes from low to high while clock line is high
- Each data transfer occurs on a rising clock edge

For more information on above two sections: [I2C Basics w/Arduino](https://www.youtube.com/watch?v=6IAkYpmA1DQ)

## 3/22: Moved on to implementing I2C on LiDAR
**Connecting STM32 to LiDAR:**
- Arduino IDE Setup: [STM32duino Reference](https://github.com/stm32duino/Arduino_Core_STM32#getting-started)
- Goal: Get distance readings from LiDAR using I2C: master is STM32 and slave is LiDAR
- Determine I2C pins on both devices and connect them. LiDAR: Pin 4 is SCL, Pin 5 is SDA
- Determine I2C address of LiDAR. Default is 0x62.
- Program will be located in this repository.
More information: [I2C on Arduino IDE](https://docs.arduino.cc/learn/communication/wire/)
LiDAR Datasheet for Quick Reference: [LiDAR Datasheet](https://www.14core.com/wp-content/uploads/2017/03/LIDAR-Lite-v1-Datasheet.pdf)

**Other Potentially Useful Links:**
[STM32 Wiki for ECE 445](https://courses.engr.illinois.edu/ece445/wiki/#/)
[I2C on STM w/CubeIDE](https://www.digikey.com/en/maker/projects/getting-started-with-stm32-i2c-example/ba8c2bfef2024654b5dd10012425fa23#:~:text=Open%20STM32CubeIDE%20and%20click%20File,I2C1_SCL%20and%20I2C1_SDA%20functions%2C%20respectively)
- I'm hoping that we can use Arduino IDE because I do not have extensive experience with embedded programming. However if required,
  STM32CubeIDE is another platform we can use to program our microcontroller.

**Current LiDAR setup with STM32 Nucleo:**

![unnamed](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/66e832c1-d52b-4d96-8d85-52a96c98d884)

## 3/25: Regular TA Meeting #5
- We removed the accelerometer and gyroscope from our project because we weren't able to integrate them well with the PCB.
- Starting work on Individual Progress Report. I hope that I'll be able to get I2C working by the deadline, because it would
  be great to have the code and results on there.

**Current Code:**

  ![unnamed](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/bfc65185-53ec-4368-a4ef-45de034cf1b7)
- According to the LiDAR datasheet, an initialization must be performed on the LiDAR before attempting to communicate with it,
  so I have included it in the code.
- This code does not work, and I am currently trying to debug it.

## 3/26: Round 2 PCB Submitted
- The board was edited to include connections missing from the previous board.
- The first step to debug in my opinion was to make sure that the LiDAR could be detected over I2C. I used code for an I2C
  scanner from [Adafruit](https://learn.adafruit.com/scanning-i2c-addresses/arduino).
- Snippet of code for understanding functionality:

  ![unnamed (1)](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/99fe2bf6-b480-4d82-aae7-ac8b4b572499)

- When this step did not work, I checked by board connections and realized that my power pin was connected incorrectly.
- The LiDAR can now be read over I2C! Screenshot of results:
  
  ![unnamed2](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/31cea962-dd94-492a-8203-63564bb0d1d4)

## 3/27: Individual Progress Report
- I still do not have my program for getting LiDAR distances via I2C working. It will unfortunately not be able to make it
  onto the Individual Progress Report.
- However, I will include all of the debugging processes I took. At the moment, the STM32 is able to detect the presence of the
  LiDAR over the I2C bus. No distances are being read through it though.
  
## 3/28: Distance Code COMPLETED
[Getting Distances with Wire Library on Arduino](https://github.com/PulsedLight3D/LIDARLite_Basics/blob/master/Arduino/LIDARLite_Wire_Library_GetDistance_ContinuousRead/LIDARLite_Wire_Library_GetDistance_ContinuousRead.ino)
- My original code was very close to the link above, but it helped identify the parts of my code that weren't working correctly.
- We are submitting our design document for a regrade, so will begin work on that.

## 4/1: Regular TA Meeting #6
- Awaiting the delivery of second round PCBs, which is our first one. We need to focus on other subsystems in the meantime,
  and have plans for if our PCB doesn't work.
- Hoping that the third round (our second) will be on schedule, since we were able to fix those connections.

## 4/8: Regular TA Meeting #7
- Discussed STM32 soldering onto the board. The pins are incredibly small, so baking it is our best bet.

## 4/9: Submitted Round 3 PCB
- We ultimately separated this submission into two different boards: one for the power subsystem, and one for the control subsystem.
- Hoping that this can allow us to isolate our subsystems, so that one board's performance will not affect the other's.

## 4/11: Attempting to program STM32F401
- I learned that we can program the STM32 on our PCB with our development board via SWD. I mapped Vin, SWDIO, SWCLK, GND,
  and NRST from the header on the dev board to the correct pins on our PCB.
- Used the pinout below:

  ![0693W00000KZbPXQA1](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/e75fa9d5-3bd2-458f-ae0e-500c7f344298)

- In our case, we did not need to worry about the right hand side since we would go through the Nucleo to the PCB. Then we
  only needed the left hand side to correctly connect to Nucleo, and then we would connect the debug header to the PCB.
- Installed STM32Cube Programmer so that Arduino can upload the code to the external PCB via SWD.
- Upload works: sometimes we get issues with inability to erase memory, so that is resolved by manually pulling the NRST
  pin down to ground.
- Used test program where we put H0 high to check: program works.
- However, program does not stay on the STM32 after it is disconnected from the dev board. We figured that it is due
  to the bootloader settings.

## 4/12: First PCB has shorts
- R10 and R11 on the board with the STM32 are now shorted, and those resistors are connected to BOOT0 and BOOT1. We may
  drill that part of the board to get rid of the resistor problems.
- Bootloader settings: I hypothesize that we need to load from flash memory, so we set BOOT0 to 0 and BOOT1 is a don't care.
  So the BOOT0 pin must go to ground, and we're planning to set BOOT1 to ground as well.

## 4/13: Need a backup plan if PCB doesn't work
- We need to resolder the STM32 on a different board. And upload isn't working due to "Failed to Erase Memory" error.
- In the meantime, we will test with our development board. I will start writing code to turn on the correct motors
  corresponding to the hall effect sensors.
- Accounting for two different versions: one on the external PCB and another on the dev board.
- I wrote two sets of code: one for the PCB, and another for our backup dev board.
- We do not have enough pins on our STM Nucleo board to account for all of our components. Therefore, we've decided to
  switch to an Arduino Mega, in the case that we do not get our PCB working.
- Wrote two more sets of code: combined LiDAR functionality with the hall effect sensor and motor code for both versions.
- Everything has been uploaded to Github in my notebook: will also upload to the code folder in the main repo.
[Arrays w/Arduino IDE](https://docs.arduino.cc/built-in-examples/control-structures/Arrays/)

## 4/14: Pivoting to Arduino Mega 2560
- The Arduino Mega came in today, and we are able to get distance measurements from the LiDAR with it.
- We need to make sure that all of the wiring in the project is secure.

## 4/16: Third Time with the STM32F401
- We got our third STM on the board with Jason's help.
- We will attempt to program this chip: connect BOOT0 and BOOT1 to GND, and use SWD with the STM32.
- We're hoping to test the hall effect module with the Arduino.
- Currently need to think about how to synchronize the LiDAR with the hall effect sensors.
- The magnet will be placed on the LiDAR, and the hall effect sensor that corresponds to the direction that the
  LiDAR is in will go low due to the presence of the magnet.
- If the LiDAR detects an obstacle 5 feet or less away in that direction, we determine the direction by checking which of
  the hall effect sensors have gone low. 
- Started work on Team Contract Fulfillment assignment.

## 4/18: Hall Effect Module Testing
- We were able to test our hall effect sensors using the code that I wrote for it. One of the sensors consistently goes low when
  the magnet goes over it and it is detected on the Arduino's serial monitor. Another one is not consistently detected by the
  magnet.
- We believe that the magnets may not be aligning correctly with the hall effect sensors as they are not in a perfect circle.
  
## 4/19: Alternate Idea: Implementing Interrupts
- We started testing interrupts with one of the hall effect sensors. The code itself is able to detect interrupts, save for
  potential delays with Arduino printing the corresponding print statement.
- However, the interrupts aren't always detected, which potentially indicates a problem with the connections and soldering of the
  board.
- We decided to manually test all the sensors to make sure that they were all working as normal when we place a magnet over it.
- We found out that all of them worked as expected except for one of them, which would turn on and off at random intervals
  that were not affected by the placement of a magnet.
- After some voltage and continuity testing, we have come to the conclusion that one of the hall effect sensors is completely busted.
- Alternative Hall Effect Proposal from Varik: we can now use a stepper motor for rotation since we have moved to our atmega dev board
    - This would now require only one hall effect sensor, and we need to know the RPM.
    - Once that is known, we can measure the time passed by, figure out the location, and map it to the hall effect sensor.

## 4/21: Haptic Motor Intensity Testing + Further Project Redesign
- Connecting the haptic motors to our board and testing that all of them can work with high and low intensities.
- This repository is for the motor we have on hand, and has some good examples we can use to verify that our motor
  can work the way we want it to: [Stepper Motor](https://github.com/Stan-Reifel/TinyStepper_28BYJ_48)
- Finished the first draft of full code that involves using a stepper motor and one hall effect sensor. The LiDAR is in
  a separate function so that it can be polled once the stepper motor has moved.
- The stepping will be very helpful, but we believe it is a little too slow for our 2 second high level requirement alone.
  We will adjust the gears accordingly, which will be handled by Matt.

## 4/22: Getting LiDAR readings for our verification table
- Met with Varik today to get LiDAR measurements for our verification table. He held the tape measure while I wired up the LiDAR and
  held it.
  
**Measuring wall distances:**
1. actual - 200 cm, lidar - 207 cm
2. actual - 150 cm, lidar - 154 cm
3. actual - 102 cm, lidar - 109 cm
4. actual - 70 cm, lidar - 72 cm
5. actual - 50 cm, lidar - 49 cm
6. actual - 30 cm, lidar - 33 cm

- Since all of these measurements are within 10% of the actual distances, we can confidently say that the LiDAR satisfies its
  corresponding requirement + verification in our tables.

## 4/23: Construction of Project
- I handed over the LiDAR to Matt so that it could be mounted on our hat. It was integrated with the slip ring and the Arduino
  Mega. Once construction was finished, I could test my code and verify that it works.

## 4/24: Testing my code
- Finished construction of the project, so I could now test my code
- CODE WORKS YAY. we're able to get readings from all directions that the LiDAR faces.
- Final construction of project:

  ![pic2](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/b654ebfa-f6c5-4670-9cc9-7fb59e24eef2)
  <img width="641" alt="Screen Shot 2024-05-02 at 2 02 48 PM" src="https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/ba01bbd6-17e4-4ddb-9454-545172cee127">


## 4/25
- Did a mock presentation run today, and compiled notes:
  - Do not read verbatim off the slides. Don't overwhelm them with content
  - Understand the purpose of every slide included.
  - Conclusions do not need to be long: make it punchy
  - Take a pause if needed
  - include videos/pictures towards the end
  - Challenges and Successes slide is v important
  - Tell a story about an actual progression of the project.

## 4/26
- Had our final demo today and it went well. It was unfortunate that we were not able to get our PCB to work, but the Arduino
  Mega came through for us big time.
- Really happy that my final code came out well. We were also able to fix it due to the 2:1 gear ratio with the stepper motor,
  which means that the LiDAR actually makes two rotations when the stepper gear makes one. Therefore, in order for the LiDAR
  to complete one revolution in 12 steps, the stepper must complete one in 24 steps.
- Hence code was changed from 2048/12 to 2048/24 for the stepper motor.
- Snippet of the final results:

  <img width="424" alt="Picture1" src="https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/76669dff-c0f8-43b6-8674-e9caf78394d7">

## 4/29
- Went through a dry run of the final presentation. Will change the slide with my code to be a flowchart instead if we have time.
- Attended a peer review for the Pancake Flipper project. It gave me a good idea of what to expect for our own presentation.

## 4/30
- Final presentation finished! It wasn't perfect, and some of our slides were jumbled. But I believe we did our best given the
  circumstances.
- Began my work on the final report. I was responsible for the control and sensing subsystems, and took on the introduction, high
  level requirements, and the abstract.
- Created a flowchart for the software operation for easier understanding.

![control unit di](https://github.com/matthewesses/ECE445_Team2_Lab_Notebooks/assets/156928022/619aaff8-c0b7-43e3-9c77-af5903132961)

## 5/1
- Continued work on the final report. Also made sure that all the references were cited in IEEE to the best of my ability.
- Finished! I am happy with our team's performance this semester, though there were definitely some ups and downs with
  getting the project to work. I believe we put out a good prototype.
