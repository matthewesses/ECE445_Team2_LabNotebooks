# 3/18: Implement I2C communication with the STM32

## Overview of I2C Protocol
- I2C has a master-slave setup, where the STM32 will be acting as the master and the components it needs to communicate with
are the slaves (LiDAR, Doppler, etc.)
- SDA (Serial Data) is the line on which the master and the slave communicate information.
- SCL (Serial Clock) is the clock line for data flow synchronization. It is generated by the master device and is responsible for synchronizing data transfer between the devices on the bus.
- Both of these lines are bi-directional.
- Devices on the I2C bus are active low, so they need pull up resistors to force the devices to high (inactive).

## I2C Data Transfer Protocol
1. Start Condition: data line is low, clock line is high
2. First 8 bits come in: first 7 - address of the slave to which data is being sent, last 1 - read/write. 0 = master writes to slave, 1 = master reads from slave
3. Acknowledge Bit - used by slave device to indicate whether previous sequence of bits was successfully received. If yes, it pulls SDA line down.
4. 8 bit address representing the internal registers of the slave device
5. Acknowledge + Data Sequence. Transfer occurs from either master or slave depending on R/W mode.
6. Stop Condition: data line goes from low to high while clock line is high
- Each data transfer occurs on a rising clock edge

For more information on above two sections: [I2C Basics w/Arduino](https://www.youtube.com/watch?v=6IAkYpmA1DQ)

## Connecting STM32 to LiDAR
- Arduino IDE Setup: [STM32duino Reference](https://github.com/stm32duino/Arduino_Core_STM32#getting-started)
- Goal: Get distance readings from LiDAR using I2C: master is STM32 and slave is LiDAR
- Determine I2C pins on both devices and connect them. LiDAR: Pin 4 is SCL, Pin 5 is SDA
- Determine I2C address of LiDAR. Default is 0x62.
- Program will be located in this repository.
More information: [I2C on Arduino IDE](https://docs.arduino.cc/learn/communication/wire/)
LiDAR Datasheet for Quick Reference: [LiDAR Datasheet](https://www.14core.com/wp-content/uploads/2017/03/LIDAR-Lite-v1-Datasheet.pdf)

## Other Potentially Useful Links:
[STM32 Wiki for ECE 445](https://courses.engr.illinois.edu/ece445/wiki/#/)
[I2C on STM w/CubeIDE](https://www.digikey.com/en/maker/projects/getting-started-with-stm32-i2c-example/ba8c2bfef2024654b5dd10012425fa23#:~:text=Open%20STM32CubeIDE%20and%20click%20File,I2C1_SCL%20and%20I2C1_SDA%20functions%2C%20respectively)

## COMPLETED YAY
[Getting Distances with Wire Library on Arduino](https://github.com/PulsedLight3D/LIDARLite_Basics/blob/master/Arduino/LIDARLite_Wire_Library_GetDistance_ContinuousRead/LIDARLite_Wire_Library_GetDistance_ContinuousRead.ino)

# 4/11
- I learned that we can program the STM32 on our PCB with our development board via SWD. I mapped Vin, SWDIO, SWCLK, GND,
  and NRST from the header on the dev board to the correct pins on our PCB.
- Installed STM32Cube Programmer so that Arduino can upload the code to the external PCB via SWD.
- Upload works: sometimes we get issues with inability to erase memory, so that is resolved by manually pulling the NRST
  pin down to ground.
- Used test program where we put H0 high to check: program works.
- However, program does not stay on the STM32 after it is disconnected from the dev board. We figured that it is due
  to the bootloader settings.

# 4/12
- R10 and R11 on the board with the STM32 are now shorted, and those resistors are connected to BOOT0 and BOOT1. We may
  drill that part of the board to get rid of the resistor problems.
- Bootloader settings: I hypothesize that we need to load from flash memory, so we set BOOT0 to 0 and BOOT1 is a don't care.
  So the BOOT0 pin must go to ground, and we're planning to set BOOT1 to ground as well.

# 4/13
- We need to resolder the STM32 on a different board.
- In the meantime, we will test with our development baord. I will start writing code to turn on the correct motors
  corresponding to the hall effect sensors.
- Accounting for two different versions: one on the external PCB and another on the dev board.
- I wrote two sets of code: one for the PCB, and another for our backup dev board.
- We do not have enough pins on our STM Nucleo board to account for all of our components. Therefore, we've decided to
  switch to an Arduino Mega, in the case that we do not get our PCB working.
- Wrote two more sets of code: combined LiDAR functionality with the hall effect sensor and motor code for both versions.
- Everything has been uploaded to Github in my notebook: will also upload to the code folder in the main repo.
[Arrays w/Arduino IDE](https://docs.arduino.cc/built-in-examples/control-structures/Arrays/)

# 4/14
- The Arduino Mega came in today, and we are able to get distance measurements from the LiDAR with it.

# 4/16
- We got our third STM on the board with Jason's help.
- We will attempt to program this chip: connect BOOT0 and BOOT1 to GND, and use SWD with the STM32.
- We're hoping to test the hall effect module with the Arduino.
- Currently need to think about how to synchronize the LiDAR with the hall effect sensors.
- The magnet will be placed on the LiDAR, and the hall effect sensor that corresponds to the direction that the
  LiDAR is in will go low due to the presence of the magnet.
- If the LiDAR detects an obstacle 5 feet or less away in that direction, we determine the direction by checking which of
  the hall effect sensors have gone low. 
- Started work on Team Contract Fulfillment assignment.

# 4/18
- We were able to test our hall effect sensors using the code that I wrote for it. One of the sensors consistently goes low when
  the magnet goes over it and it is detected on the Arduino's serial monitor. Another one is not consistently detected by the
  magnet.
- We believe that the magnets may not be aligning correctly with the hall effect sensors as they are not in a perfect circle.
  
# 4/19
- We started testing interrupts with one of the hall effect sensors. The code itself is able to detect interrupts, save for
  potential delays with Arduino printing the corresponding print statement.
- However, the interrupts aren't always detected, which potentially indicates a problem with the connections and soldering of the
  board.
