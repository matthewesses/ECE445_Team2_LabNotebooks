# 3/18: Implement I2C communication with the STM32

## Overview of I2C Protocol
- I2C has a master-slave setup, where the STM32 will be acting as the master and the components it needs to communicate with
are the slaves (LiDAR, Doppler, etc.)
- SDA (Serial Data) is the line on which the master and the slave communicate information.
- SCL (Serial Clock) is the clock line for data flow synchronization. It is generated by the master device and is responsible for synchronizing data transfer between the devices on the bus.
- Both of these lines are bi-directional.
- Devices on the I2C bus are active low, so they need pull up resistors to force the devices to high (inactive).

## I2C Data Transfer Protocol
1. Start Condition: data line is low, clock line is high
2. First 8 bits come in: first 7 - address of the slave to which data is being sent, last 1 - read/write. 0 = master writes to slave, 1 = master reads from slave
3. Acknowledge Bit - used by slave device to indicate whether previous sequence of bits was successfully received. If yes, it pulls SDA line down.
4. 8 bit address representing the internal registers of the slave device
5. Acknowledge + Data Sequence. Transfer occurs from either master or slave depending on R/W mode.
6. Stop Condition: data line goes from low to high while clock line is high
- Each data transfer occurs on a rising clock edge

For more information on above two sections: [I2C Basics w/Arduino](https://www.youtube.com/watch?v=6IAkYpmA1DQ)

## Connecting STM32 to LiDAR
- Arduino IDE Setup: [STM32duino Reference](https://github.com/stm32duino/Arduino_Core_STM32#getting-started)
- Goal: Get distance readings from LiDAR using I2C: master is STM32 and slave is LiDAR
- Determine I2C pins on both devices and connect them. LiDAR: Pin 4 is SCL, Pin 5 is SDA
- Determine I2C address of LiDAR. Default is 0x62.
- Program will be located in this repository.
More information: [I2C on Arduino IDE](https://docs.arduino.cc/learn/communication/wire/)
LiDAR Datasheet for Quick Reference: [LiDAR Datasheet](https://www.14core.com/wp-content/uploads/2017/03/LIDAR-Lite-v1-Datasheet.pdf)

## Other Potentially Useful Links:
[STM32 Wiki for ECE 445](https://courses.engr.illinois.edu/ece445/wiki/#/)
[I2C on STM w/CubeIDE](https://www.digikey.com/en/maker/projects/getting-started-with-stm32-i2c-example/ba8c2bfef2024654b5dd10012425fa23#:~:text=Open%20STM32CubeIDE%20and%20click%20File,I2C1_SCL%20and%20I2C1_SDA%20functions%2C%20respectively)

## COMPLETED YAY
[Getting Distances with Wire Library on Arduino](https://github.com/PulsedLight3D/LIDARLite_Basics/blob/master/Arduino/LIDARLite_Wire_Library_GetDistance_ContinuousRead/LIDARLite_Wire_Library_GetDistance_ContinuousRead.ino)

## 4/11
- I learned that we can program the STM32 on our PCB with our development board via SWD. I mapped Vin, SWDIO, SWCLK, GND,
  and NRST from the header on the dev board to the correct pins on our PCB.
- Installed STM32Cube Programmer so that Arduino can upload the code to the external PCB via SWD.
- Upload works: sometimes we get issues with inability to erase memory, so that is resolved by manually pulling the NRST
  pin down to ground.
- Used test program where we put H0 high to check: program works.
- However, program does not stay on the STM32 after it is disconnected from the dev board. We figured that it is due
  to the bootloader settings.

## 4/12
- R10 and R11 on the board with the STM32 are now shorted, and those resistors are connected to BOOT0 and BOOT1. We may
  drill that part of the board to get rid of the resistor problems.
- Bootloader settings: I hypothesize that we need to load from flash memory, so we set BOOT0 to 0 and BOOT1 is a don't care.
  So the BOOT0 pin must go to ground, and we're planning to set BOOT1 to ground as well.
